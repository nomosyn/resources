# This template is generated by tangling the file: "story-template-builder.org"
# STORY-TEMPLATE-VERSION: 4.0.0

#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t ^:nil
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+INFOJS_OPT:
#+LATEX_HEADER:
#+TITLE: Coding style


* Coding style

  - Team _expects_ a coding style to be respected _so that_ code is relevant, clear and short.



** Context

   - Version: 1.0.3
   - Contribution policy: [[http://rfc.zeromq.org/spec:22][C4.1]]
   - Short name: Coding style
   - Contributors:
       - Full name: Pierre-Henry Fröhring, contact: frohring.pierrehenry@gmail.com
       - Full name: Bastien Faure, contact: contact@bastienfaure.fr



*** Definitions

    - The key words *MUST*, *MUST NOT*, *REQUIRED*, *SHALL*, *SHALL NOT*,
      *SHOULD*, *SHOULD NOT*, *RECOMMENDED*, *MAY*, and *OPTIONAL* in this
      document are to be interpreted as described in [[http://tools.ietf.org/html/rfc2119][RFC 2119]]

    - <<workingbackwards>> [[http://www.allthingsdistributed.com/2006/11/working_backwards.html][Working backwards]]

    - <<cretan>> [[http://hintjens.com/blog:81][The cretan method]]

    - <<calloption>> [[http://www.higherorderlogic.com/2010/07/bad-code-isnt-technical-debt-its-an-unhedged-call-option/][Bad code is unhedged call option]]

    - <<ideaprog>> [[http://www.infoq.com/presentations/Expression-of-Ideas][Programming for the expression of ideas]]

    - <<curryhoward>> [[http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence][Curry-Howard-Lambek correspondence]]

    - <<proof>> [[http://research.microsoft.com/en-us/um/people/lamport/pubs/proof.pdf][Leslie Lamport on writing a proof]]

    - <<tarpit>> [[https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf?raw=true][Out of the tar pit]]

    - <<google-js>> [[https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml][Google coding style]]

    - <<crock-js>> [[http://www.amazon.com/exec/obidos/ASIN/0596517742/wrrrldwideweb][JS the good parts]]

    - <<class>> [[https://github.com/nomosyn/js-coding-style/blob/master/class-template.js][Class template]]

    - <<story-template>> [[https://github.com/nomosyn/js-coding-style/blob/master/story-template.org][Story template]]

    - <<README>> README: a file following the [[story-template][Story template]]

    - <<package>> [[http://docs.meteor.com/#/full/packagejs][Meteor package]]

    - <<semver>> [[http://semver.org/][Semantic versioning]]

    - <<catforprog>> [[http://www.codemesh.io/static/upload/media/14153791979335jeremygibbons.pdf][Categories for programmers]]

    - <<connthings>> [[http://www.codemesh.io/static/upload/media/1416242738765617codemesh14joearmstrong.pdf][Connecting things]]

    - <<ramda>> [[http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/][Ramda]]

    - <<frp>> [[https://gist.github.com/staltz/868e7e9bc2a7b8c1f754][FRP]]

    - <<meteor>> [[https://www.meteor.com/][Meteor]]



** Init State

   - Little or no consistency accross code, redunduncies, etc...  bad code that
     more or less works.



** Problem

   - The maintainers must either rewrite contributions by hand, or must abandon
     any attempt to enforce a consistent *voice* across a project; so code is :
       - Hard to write correctly, and errors are rapidly clear

       - Hard to read and understand

       - Hard to reuse and remix, in whole or in fragments

       - => Too expensive to create, read, update, delete functionalities.



** End State

   - Following this coding style make the code:
       - Short
           - idealy, no code should be produced to implement and maintain a
             functionality... but that's magic.  Real world demands that to get
             something, something else should be given.  Let's be lazy and give
             the bare minimum.

       - Clear
           - Jumping from a file written by *P* to a file written by *B* looks
             like going from english to english, not russian to chinese.

       - => create, read, update, delete functionalities is less expensive.



** Rationale

   - This coding style is inpired by these highly recommended papers :
       - [[workingbackwards][Working backwards]]

       - [[cretan][The cretan method]]

       - [[calloption][Bad code is unhedged call option]]

       - [[ideaprog][Programming for the expression of ideas]]

       - [[curryhoward][Curry-Howard-Lambek correspondence]]

       - [[proof][Leslie Lamport on writing a proof]]

       - [[tarpit][Out of the tar pit]]

       - [[google-js][Google coding style]]

       - [[crock-js][Crockford]]

       - [[catforprog][Categories for programmers]]

       - [[connthings][Connecting things together]]

       - [[ramda][ramda library]]

       - [[frp][FRP]]



** Solution

   - The language for all names and comments *SHALL* be English.

   - <<unitOfWork>> A unit of work is:
       - a [[meteor][meteor application]] that uses functionalities implemented as one or more [[package][meteor packages]].
           - Each meteor package:
               - *MUST* be at most one level deep.

               - *MUST* contain a [[README][README]]

               - *MAY* contain one or more [[class][classes]] where each class covers one
                 area of work.

               - *SHOULD* contain tests for api exposed

               - *MUST NOT* contain anything else.

   - <<NamingRules>> Naming rules:
       - Short words that are simple, clear, and obvious to the reader...

       - ...NOT invented words or acronyms.

       - =functionNamesLikeThis= begin by a verb. Ex: =destroy=, =insert=,
         =lookup=, =build=, =isReady=, =isEmpty=.

       - =variableNamesLikeThis= and made only out of nouns. Ex: =color=,
         =status=.

       - =TypeNamesLikeThis=

       - =EnumNamesLikeThis=

       - =CONSTANT_VALUES_LIKE_THIS=

       - =foo.namespaceNamesLikeThis.bar=

       - =file-names-like-this.js=



*** Javascript

    - [[NamingRules][Naming rules]] *MUST* be followed.

    - JavaScript code *SHALL* be executed in strict mode.

    - All variables *SHALL* be declared at the top of functions.

    - =new= keyword *SHOULD NOT* be used.

    - Instructions *SHALL* be finished by =;= wherever possible.

    - The return value expression *MUST* start on the same line as the return
      keyword.

    - You *MUST NOT* use =with= keyword.

    - You *MUST NOT* use =eval= keyword.

    - You *SHOULD* use ~===~ instead of  ~==~; ~!==~ instead of ~!=~.

    - You *MUST NOT* make circular reference (<=> memory leak) using closures
      #+NAME: closure_memory_leak
      #+BEGIN_SRC js
        /** Because function onclick is defined in the scope of foo then it keeps a
         ,*  reference to `element`, `a` and `b`.
         ,*
         ,*  We end up with: element -> onclick -> function -> (element, a, b) We have a
         ,*  cycle: element -> ... -> element that will not be garbage collected: memory
         ,*  leak, slow code.
         ,*/
        function foo(element, a, b) {
            element.onclick = function() { /* uses a and b */ };
        }

        /** Better do: */
        function bar(a,b) { return function() { /* uses a and b */ }; }
        function foo(element, a, b) { element.onclick = bar(a, b); }
      #+END_SRC

    - You *MUST NOT* modify prototypes of builtin objects.

    - If a method is longer than a line or two and makes use of =this=, then you
      *MUST* begin with =var self = this=, and always use =self=, never =this=.

    - Exceptions *MUST* be caught.

    - You *MUST* use =null= and *MUST NOT* use =undefined= to signify the absence of
      something or any valid value.

    - Indentation *SHALL* be 4 spaces per level. Tab characters *SHALL NOT* be used
      in code.

    - Code lines of more than 80 characters *SHOULD* be folded.

    - Code *SHOULD* work as expected, at least in Chrome and Firefox.

    - Comments *MUST* follow the [[class][class]] example, where:
        - =uid= is defined as: given a ~uuid := 68DE7F67-DFA8-4DB9-9287-A1242B0BDDBA~, then ~uid := DFA8~.

        - =(def <uid>) <definition>= binds the =<uid>= to the definition =<definition>=.

        - =(ref <uid>)= references a =<uid>=.

        - =(todo (def <uid>)) <definition>=; means that this =<definition>= is to be
                                             implemented.

        - =(fixme <uid>) <definition>=; defines a problem to solve.

        - =(block (def <uid>)) <definition>=; =<definition>= is implemented as a block of lines to be defined.
            - =(begin (ref <uid>))=; defines the beginning of the implementation.

            - =(end (ref <uid>))=; defines the end of the implementation.


    - If a version number is needed, it *MUST* follow the [[semver][semantic versioning]] convention.



*** User interface code.

    - [[https://github.com/meteor/meteor/wiki/Meteor-Style-Guide][source:meteor-style-guide]]

    - Code should be strictly divided into user interface code, which can print
      messages, read input, make sounds, or otherwise engage with the user; and
      library code, which is not allowed to do any of these things.

    - The amount of user interface code should be kept as small as possible. It
      should focus on getting instructions from the user, calling library code
      to carry out those instructions, and explaining to the user what happened
      – wherever possible, the logic to present this user interface should be
      separated from the library code that does the actual work, for clarity,
      reusability, and modularity.

    - As an example of this principle, when a random function in the codebase
      needs to report an error or print a status message, it is not allowed to
      write to stdout or stderr. If any function is allowed to write to the
      terminal, it becomes impossible to gain any confidence in the quality of
      our UX, because it is impossible to reason about what messages will be
      printed when without looking at every single write statement in the
      codebase and reasoning about the call graph. Instead, the function needs
      to expose some kind of interface to its caller (such as a particular
      return value, or a callback) that indicates the condition that has
      occurred. The caller needs to plumb that back to its own caller, and so
      forth, until we reach user interface code that can figure out the right
      way to present the condition to the user (if it thinks the user cares
      about it).



*** EditorConfig
    #+INCLUDE: "../../.editorconfig" example



*** JSHint
    #+INCLUDE: "../../.jshintrc" example
